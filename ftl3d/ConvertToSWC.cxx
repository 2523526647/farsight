/***
/brief Code to convert superellise xml file to SWC file.
/author  Amit Mukherjee
/date May 09, 2009
*/


#include "tinyxml.h"
#include "TraceNode.h"
#include <string>
#include <fstream>
#include <map>
#include <vector>

void WriteSWCFile(const std::string& , const std::vector<TraceNode*>& );
bool ReadNodeXMLFile(const char* , std::vector<TraceNode*>& );

int main (int argc, char *argv[])	{

	if (argc != 3)	{
		std::cout << "Usage: "<<argv[0] << " [SuperellipseXMLFilename] [SWCFilename]" <<std::endl;
		return EXIT_FAILURE;
	}
	std::string XMLFilename(argv[1]);
	std::string SWCFilename(argv[2]);
	std::vector<TraceNode*> NodeContainer ;
	std::cout << "Reading file " << argv[1] << std::endl;
	if (ReadNodeXMLFile(XMLFilename.c_str(), NodeContainer ) )	{
		std::cout << "Reading success. " << NodeContainer.size() << " superellise found" << std::endl << "Constructing SWC tree" << std::endl;
		WriteSWCFile(SWCFilename, NodeContainer);
	}
}

void WriteSWCFile(const std::string& SWCFilename, const std::vector<TraceNode*>& NodeContainer)	{

	std::ofstream swc;
	swc.open(SWCFilename.c_str(), std::ios::out);

	const unsigned int numNodes = NodeContainer.size();
	std::map<long, int> reg;

	swc << "# File generated by Superellipse to SWC converter" << std::endl;

	// scan the graph
	unsigned int numDone = 1, numTrees = 1;;

	//initialize the first element as grandparent
	//if you know the SOMA, then this should be the SOMA and initilise likewise, here I have choosen arbit.
	TraceNode* node = NodeContainer[0];
	unsigned int ID = 1;
	reg[node->ID] = ID;
	swc << ID << " 10 " << node->loc[0] << " " << node->loc[1] << " " << node->loc[2] << " " << node->radius << "  -1" << std::endl;

	while (numDone < numNodes)	{
		unsigned char IsChanged = 0;
		std::vector<TraceNode*>::const_iterator fit = NodeContainer.begin();
		for(fit = NodeContainer.begin(); fit < NodeContainer.end(); fit++)	{
			if (reg[(*fit)->ID] == 0)	{
				for (int i = 0; i < (*fit)->nbrID.size(); i++)	{
					if (reg[(*fit)->nbrID[i]] != 0)	{
						ID++;
						swc << ID << " 10 " << (*fit)->loc[0] << " " << (*fit)->loc[1] << " " <<
							(*fit)->loc[2] << " " << (*fit)->radius << "  " << reg[(*fit)->nbrID[i]] << std::endl;
						std::cout <<"\r" << (numDone*100/numNodes) << " % complete          ";
						reg[(*fit)->ID] = ID;
						IsChanged = 1;
						numDone++;
						break;
					}
				}
			}
			else	{
				if(IsChanged == 1)
					break;
			}
		}
		std::vector<TraceNode*>::const_reverse_iterator rit;
		for(rit = NodeContainer.rbegin(); rit < NodeContainer.rend(); rit++)	{
			if (reg[(*rit)->ID] == 0)	{
				for (int i = 0; i < (*rit)->nbrID.size(); i++)	{
					if (reg[(*rit)->nbrID[i]] != 0)	{
						ID++;
						swc << ID << " 10 " << (*rit)->loc[0] << " " << (*rit)->loc[1] << " " <<
							(*rit)->loc[2] << " " << (*rit)->radius << "  " << reg[(*rit)->nbrID[i]] << std::endl;
						std::cout <<"\r" << (numDone*100/numNodes) << " % complete          ";
						reg[(*rit)->ID] = ID;
						IsChanged = 2;
						numDone++;
						break;
					}
				}
			}
			else	{
				if(IsChanged == 2)
					break;
			}
		}

		if ((IsChanged == 0) && (numDone < numNodes))	{
			//begin a new tree
			std::vector<TraceNode*>::const_iterator fit;
			for(fit = NodeContainer.begin(); fit < NodeContainer.end(); fit++)	{
				if (reg[(*fit)->ID] == 0)	{
					ID++;
					swc << ID << " 10 " << (*fit)->loc[0] << " " << (*fit)->loc[1] << " " << (*fit)->loc[2] << " " << (*fit)->radius << "  -1" << std::endl;
					std::cout <<"\r" << (numDone*100/numNodes) << " % complete          ";
					reg[(*fit)->ID] = ID;
					numDone++;
					numTrees++;
					break;
				}
			}
		}
	}
	std::cout << std::endl << "Done ... Saving in file " << SWCFilename <<std::endl;
	swc.close();
}

bool ReadNodeXMLFile(const char* xmlfname, std::vector<TraceNode*>& NodeContainer) {
	NodeContainer.reserve(10000);
	TiXmlDocument doc(xmlfname);
	if (!doc.LoadFile()) {
		return false;
	}

	//scan each Superellipse
	TiXmlNode* xmlnode;

	for ( xmlnode = doc.FirstChild(); xmlnode != 0; xmlnode = xmlnode->NextSibling()) 	{

		//verify if the xmlnode is a type element
		if (xmlnode->Type()!=TiXmlNode::ELEMENT)	{
			continue;
		}

		//verify if the xmlnode is a superellipse, if not
		if (strcmp(xmlnode->Value(),"Superellipse"))	{
			continue;
		}

		TraceNode *n = new TraceNode();
		TiXmlAttribute* pAttrib = xmlnode->ToElement()->FirstAttribute();
		while (pAttrib)	{
			if (!strcmp(pAttrib->Name(),"ID"))	{
				int temp = -1;
				if (pAttrib->QueryIntValue(&temp)==TIXML_SUCCESS)	{
					n->ID = temp;
				}
			}
			else if (!strcmp(pAttrib->Name(),"TraceID"))	{
				int temp = -1;
				if (pAttrib->QueryIntValue(&temp)==TIXML_SUCCESS)	{
					n->TraceID = temp;
				}
			}

			else if (!strcmp(pAttrib->Name(),"x"))	{
				double temp = -1.0;
				if (pAttrib->QueryDoubleValue(&temp)==TIXML_SUCCESS)	{
					n->loc[0] = temp;
				}
			}

			else if (!strcmp(pAttrib->Name(),"y"))	{
				double temp = -1.0;
				if (pAttrib->QueryDoubleValue(&temp)==TIXML_SUCCESS)	{
					n->loc[1] = temp;
				}
			}

			else if (!strcmp(pAttrib->Name(),"z"))	{
				double temp = -1.0;
				if (pAttrib->QueryDoubleValue(&temp)==TIXML_SUCCESS)	{
					n->loc[2] = temp;
				}
			}

			else if (!strcmp(pAttrib->Name(),"a1"))	{
				double temp = -1.0;
				if (pAttrib->QueryDoubleValue(&temp)==TIXML_SUCCESS)	{
					if (n->radius > 0.0)	{
						n->radius = 0.5*(n->radius + temp);
					}
					else {
						n->radius = temp;
					}
				}
			}

			else if (!strcmp(pAttrib->Name(),"a2"))	{
				double temp = -1.0;
				if (pAttrib->QueryDoubleValue(&temp)==TIXML_SUCCESS)	{
					if (n->radius > 0.0)	{
						n->radius = 0.5*(n->radius + temp);
					}
					else {
						n->radius = temp;
					}
				}
			}

			pAttrib=pAttrib->Next();
		}

		TiXmlNode* nbr;
		for ( nbr = xmlnode->FirstChild(); nbr != 0; nbr = nbr->NextSibling())		{
			TiXmlAttribute* nAttr = nbr->ToElement()->FirstAttribute();
			if (!strcmp(nAttr->Name(),"ID"))	{
				int temp = -1;
				if (nAttr->QueryIntValue(&temp)==TIXML_SUCCESS)
					n->nbrID.push_back(temp);
			}
		}

		//store in container
		NodeContainer.push_back(n);
	}
	return true;

}
